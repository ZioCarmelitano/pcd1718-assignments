\documentclass[a4paper]{article}

\usepackage{geometry}

\usepackage{caption}
\usepackage{amsmath}

\captionsetup[table]{position=bottom}

%\usepackage[cm]{fullpage}

% some very useful LaTeX packages include:

%\usepackage{cite}      % Written by Donald Arseneau
                        % V1.6 and later of IEEEtran pre-defines the format
                        % of the cite.sty package \cite{} output to follow
                        % that of IEEE. Loading the cite package will
                        % result in citation numbers being automatically
                        % sorted and properly "ranged". i.e.,
                        % [1], [9], [2], [7], [5], [6]
                        % (without using cite.sty)
                        % will become:
                        % [1], [2], [5]--[7], [9] (using cite.sty)
                        % cite.sty's \cite will automatically add leading
                        % space, if needed. Use cite.sty's noadjust option
                        % (cite.sty V3.8 and later) if you want to turn this
                        % off. cite.sty is already installed on most LaTeX
                        % systems. The latest version can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/cite/
\usepackage[inline]{enumitem}

\usepackage{graphicx}   % Written by David Carlisle and Sebastian Rahtz
                        % Required if you want graphics, photos, etc.
                        % graphicx.sty is already installed on most LaTeX
                        % systems. The latest version and documentation can
                        % be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/required/graphics/
                        % Another good source of documentation is "Using
                        % Imported Graphics in LaTeX2e" by Keith Reckdahl
                        % which can be found as esplatex.ps and epslatex.pdf
                        % at: http://www.ctan.org/tex-archive/info/

%\usepackage{psfrag}    % Written by Craig Barratt, Michael C. Grant,
                        % and David Carlisle
                        % This package allows you to substitute LaTeX
                        % commands for text in imported EPS graphic files.
                        % In this way, LaTeX symbols can be placed into
                        % graphics that have been generated by other
                        % applications. You must use latex->dvips->ps2pdf
                        % workflow (not direct pdf output from pdflatex) if
                        % you wish to use this capability because it works
                        % via some PostScript tricks. Alternatively, the
                        % graphics could be processed as separate files via
                        % psfrag and dvips, then converted to PDF for
                        % inclusion in the main file which uses pdflatex.
                        % Docs are in "The PSfrag System" by Michael C. Grant
                        % and David Carlisle. There is also some information
                        % about using psfrag in "Using Imported Graphics in
                        % LaTeX2e" by Keith Reckdahl which documents the
                        % graphicx package (see above). The psfrag package
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/psfrag/

%\usepackage{subfigure} % Written by Steven Douglas Cochran
                        % This package makes it easy to put subfigures
                        % in your figures. i.e., "figure 1a and 1b"
                        % Docs are in "Using Imported Graphics in LaTeX2e"
                        % by Keith Reckdahl which also documents the graphicx
                        % package (see above). subfigure.sty is already
                        % installed on most LaTeX systems. The latest version
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/subfigure/

\usepackage{url}        % Written by Donald Arseneau
                        % Provides better support for handling and breaking
                        % URLs. url.sty is already installed on most LaTeX
                        % systems. The latest version can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/other/misc/
                        % Read the url.sty source comments for usage information.

%\usepackage{stfloats}  % Written by Sigitas Tolusis
                        % Gives LaTeX2e the ability to do double column
                        % floats at the bottom of the page as well as the top.
                        % (e.g., "\begin{figure*}[!b]" is not normally
                        % possible in LaTeX2e). This is an invasive package
                        % which rewrites many portions of the LaTeX2e output
                        % routines. It may not work with other packages that
                        % modify the LaTeX2e output routine and/or with other
                        % versions of LaTeX. The latest version and
                        % documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/contrib/supported/sttools/
                        % Documentation is contained in the stfloats.sty
                        % comments as well as in the presfull.pdf file.
                        % Do not use the stfloats baselinefloat ability as
                        % IEEE does not allow \baselineskip to stretch.
                        % Authors submitting work to the IEEE should note
                        % that IEEE rarely uses double column equations and
                        % that authors should try to avoid such use.
                        % Do not be tempted to use the cuted.sty or
                        % midfloat.sty package (by the same author) as IEEE
                        % does not format its papers in such ways.
\usepackage{amssymb}
\usepackage{amsmath}    % From the American Mathematical Society
                        % A popular package that provides many helpful commands
                        % for dealing with mathematics. Note that the AMSmath
                        % package sets \interdisplaylinepenalty to 10000 thus
                        % preventing page breaks from occurring within multiline
                        % equations. Use:
%\interdisplaylinepenalty=2500
                        % after loading amsmath to restore such page breaks
                        % as IEEEtran.cls normally does. amsmath.sty is already
                        % installed on most LaTeX systems. The latest version
                        % and documentation can be obtained at:
                        % http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/
\usepackage{latexsym}
\usepackage{amsthm}

\usepackage{verbatim}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}

\usepackage{algorithm}
\usepackage{algpseudocode}
\algrenewcommand{\algorithmiccomment}[1]{$\left(\text{#1}\right)$}

\usepackage{color}

\definecolor{ideanumber}{rgb}{0.0,0.0,1.0}
\definecolor{ideacomment}{rgb}{0.5,0.5,0.5}
\definecolor{ideakeyword}{rgb}{0.0,0.0,0.5}
\definecolor{ideastring}{rgb}{0.0,0.5,0.0}

\usepackage{listings}
\lstset{frame=tb,
    language=Java,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=left,
    numbersep=2pt,                   % how far the line-numbers are from the code
    numberstyle=\tiny\color{ideacomment},
    keywordstyle=\color{ideakeyword},
    commentstyle=\color{ideacomment},
    stringstyle=\color{ideastring},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
}

% Other popular packages for formatting tables and equations include:

%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty which improves the
% LaTeX2e array and tabular environments to provide better appearances and
% additional user controls. array.sty is already installed on most systems.
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/

% V1.6 of IEEEtran contains the IEEEeqnarray family of commands that can
% be used to generate multiline equations as well as matrices, tables, etc.

% Also of notable interest:
% Scott Pakin's eqparbox package for creating (automatically sized) equal
% width boxes. Available:
% http://www.ctan.org/tex-archive/macros/latex/contrib/supported/eqparbox/

% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
\newcommand\textsup[1]{$^{\text{#1}}$}
\newcommand\textsub[1]{$_{\text{#1}}$}

% Define document title and author
\title{\LARGE \bf
Assignent \#3
}
\author{
    Martina Magnani\\
    \texttt{martina.magnani8@studio.unibo.it}
    \and
    Nicola Piscaglia\\
    \texttt{nicola.piscaglia2@studio.unibo.it}
    \and
    Mattia Vandi\\
    \texttt{mattia.vandi@studio.unibo.it}
}
\date{}

% Your document starts here!
\begin{document}

\maketitle

\section{Analisi del problema}\label{analisi-del-problema}

L'obiettivo della consegna è implementare Implementare in Java o in Scala una versione ad attori del gioco \textit{``The Game of Life''}.\\
Il gioco consiste nel calcolare e visualizzare l'evoluzione della matrice di celle che caratterizza il gioco, come sequenza di fotogrammi (ognuno dei quali rappresenta lo stato del mondo).\\
Nella matrice, ogni cella può essere in uno dei due stati possibili, \textit{live} o \textit{dead}.\\
Dato lo stato $s\left(t\right)$ della matrice, lo stato $s\left(t + 1\right)$ si computa con le seguenti regole:

\begin{itemize}
\item
  una cella $m\left[i,j\right]$ che nello stato $s\left(t\right)$ è \textit{live} e ha zero o al più una cella vicina \textit{live} (e le altre \textit{dead}), nello stato $s\left(t + 1\right)$ diventa \textit{dead} (``muore di solitudine'')
\item
  una cella $m\left[i,j\right]$ che nello stato $s\left(t\right)$ è \textit{live} e ha quattro o più celle vicine \textit{live}, nello stato $s\left(t + 1\right)$ diventa \textit{dead} (``muore di sovrappopolamento'')
\item
  una cella $m\left[i,j\right]$ che nello stato $s\left(t\right)$ è \textit{live} e ha due o tre celle vicine \textit{live}, nello stato $s\left(t + 1\right)$ rimane \textit{live} (``sopravvive'')
\item
  una cella $m\left[i,j\right]$ che nello stato $s\left(t\right)$ è \textit{dead} e ha tre celle vicine \textit{live}, nello stato $s\left(t + 1\right)$ diventa \textit{live}
\end{itemize}
Il gioco deve presentare un'interfaccia grafica con pulsanti \texttt{start} e \texttt{stop} con cui si fa partire e fermare il gioco.
Ogni stato del gioco deve essere visualizzato, insieme al numero di celle nello stato \textit{live}.

\subsection{Requisiti del sistema}\label{requisiti-del-sistema}

\begin{itemize}
\item
  Il programma deve funzionare anche con matrici di dimensioni significative (ad es. 5000x5000);
\item
  Massimizzare il throughput, minimizzando il tempo di calcolo di ciascun fotogramma ed eventualmente anche della sequenza di fotogrammi;
\item
  Massimizzare la reattività della GUI;
\item
  Studiare e implementare meccanismi di coordinazione/sincronizzazione basati sullo scambio di messaggi.
\end{itemize}

\section{Descrizione della soluzione proposta}\label{descrizione-della-soluzione-proposta}

\subsection{Architettura del sistema}\label{architettura-del-sistema}

L'architettura del sistema è stata scomposta in tre livelli utilizzando il pattern Model View Presenter, a differenza della prima consegna l'aggiornamento della scheramta utente e l'aggiornamento della scacchiera di gioco è completamente demandata ad un insieme di attori, di conseguenza vi sono tre moduli: il dominio applicativo, gli attori e l'interfaccia grafica:

\begin{itemize}
\item
  Nel primo livello vi è una rappresentazione object-oriented delle componenti del problema;
\item
  Nel secondo livello è stata incapsulata la logica di aggiornamento del gioco e dell'interfaccia utente;
\item
  Nel terzo livello viene organizzata l'interfaccia grafica che permette la visualizzazione del gioco e l'interazione con l'utente.
\end{itemize}

\subsection{Implementazione}\label{implementazione}

\subsubsection{Dominio applicativo}\label{dominio-applicativo}

Abbiamo implementato il dominio applicativo attraverso due classi: \texttt{Cell} e \texttt{Board}.\\
L'enumerazione \texttt{Cell} rappresenta lo stato di una cella della scacchiera che può essere \textit{live} o \textit{dead}.
La classe \texttt{Board} rappresenta la scacchiera di gioco. Questa è caratterizzata da un'\textit{altezza} e una \textit{larghezza} variabili e dalla possibilità di recuperare/impostare lo stato di una cella date le coordinate $x$ e $y$.

\subsubsection{Attori}\label{attori}

Abbiamo implementato un attore \texttt{BoardUpdater} che si occupa dell'aggiornamento della scacchiera di gioco.

Dell'attore \texttt{BoardUpdater} è possibile configurare il numero di \texttt{Worker} che verranno utilizzati per aggiornare la schermata di gioco (ognuno dei quali verrà tradotto in un nuovo attore).\\
Il messaggio \texttt{StartUpdate}, inviato dal \texttt{BoardUpdater}, informa ogni \texttt{Worker} della porzione di scacchiera di gioco che dovrà aggiornare.\\
Il messaggio \texttt{StartPartialUpdate}, inviato da un \texttt{Worker} sé stesso, informa sé stesso sulla porzione di scacchiera di gioco da aggiornare prima di passare alla successiva. Tale strategia consente ad un attore di rimanere reattivo ai messaggi ricevuti da altri attori.\\
Il messaggio \texttt{FinishedPartialUpdate}, inviato da un \texttt{Worker} a sé stesso, informa sé stesso che un aggiornamento parziale è terminato. Se l'aggiornamento parziale completato è l'ultimo allora informa sé stesso che può informare il \texttt{BoardUpdater} che l'aggiornamento assegnato al \texttt{Worker} è terminato, altrimenti l'attore informa sé stesso sulla prossima porzione di scacchiera da aggiornare.\\
Il messagio \texttt{FinishedUpdate}, inviato ad un \texttt{Worker}, informa il \texttt{BoardUpdater} che l'aggiornamento assegnato ad un \texttt{Worker} è termianto. Se l'aggiornamento terminato è anche l'ultimo allora notifica il mittente fornendogli la scacchiera di gioco aggiornata.\\
Il messagio \texttt{NewBoard}, inviato dal \texttt{BoardUpdater}, informa il \texttt{GuiUpdater} sulla prossima scacchiera di gioco da visualizzare all'utente.

\subsubsection{Interfaccia utente}\label{interfaccia-utente}

L’interfaccia utente è stata realizzata con JavaFX ed è costituita da due schermate: nella prima si permette all’utente di settare le dimensioni della scacchiera di gioco (altezza e larghezza) ed il numero di \texttt{Worker}. Nella seconda si visualizza la scacchiera e sono presenti due pulsanti \textit{start} e \textit{stop}. Lo \textit{start} permette l’avvio e la pausa del gioco, mentre lo \textit{stop} la terminazione.\\
Utilizzando il pattern Factory sono stati incapsulate in una apposita classe le funzioni per la costruzione delle finestre grafiche. Le callback di queste finestre sono definite da opportuni \texttt{Presenter} che incapsulano la logica di controllo dei componenti (form, pulsanti, ...) di cui sono costituite.\\
La computazione relativa alla coordinazione dell’aggiornamento matriciale e grafico della scacchiera è effettuata dall'attore \texttt{GuiUpdater} e questo permette di mantenere l’interfaccia grafica (gestita dal JavaFX Application Thread) reattiva ed in grado di intercettare l’input dell’utente.\\
Il messaggio \texttt{Start}, inviato dal \texttt{GuiUpdater} al \texttt{BoardUpdater}, si occupa di avviare l'aggiornamento della schermata di gioco passata in input.\\
Il messaggio \texttt{Pause}, inviato dal \texttt{GamePresenter} a fronte della pressione del pulsante associato, informa l'attore \texttt{GuiUpdater} della messa in pausa del gioco da parte dell'utente.\\
Il messaggio \texttt{Resume}, inviato dal \texttt{GamePresenter} a fronte della pressione del pulsante associato, informa l'attore \texttt{GuiUpdater} della ripresa del gioco.\\
Il messaggio\texttt{Stop}, inviato dal \texttt{GamePresenter} a fronte della pressione del pulsante associato, informa l'attore \texttt{GuiUpdater}, che informerà gli altri attori sulla volontà dell'utente di voler termianre la simulazione.\\
Il Presenter addetto alla gestione degli eventi di gioco (\texttt{GamePresenter}) utilizza un servizio di rendering offerto dalla classe \texttt{RenderingService} nella quale sono state incapsulate le funzioni relative al disegno della scacchiera di gioco.\\
Quest'ultima è stata realizzata utilizzando un componente grafico \texttt{Canvas} sul quale vengono disegnate le celle attraverso la classe \texttt{PixelWriter} di JavaFX: una classe ottimizzata per il disegno dei singoli pixel.

\section{Dinamica del sistema}\label{dinamica-del-sistema}
La dinamica del sistema è stata rappresentata formalmente con le Reti di Petri. Le piazze (\textit{places}) del livello corrispondono ai \texttt{Worker} che concorrono all'aggiornamento della scacchiera di gioco; in questo esempio è stato scelto di mostrare il sistema nel caso se ne utilizzino 4.
\begin{comment}
\begin{figure}[H]
    \centering
    \includegraphics[width=110mm]{res/reti_di_petri_assigment1.png}
    \caption{Petri Net che modella la dinamica della computazione dello stato di gioco}
    \label{fig:petrinets}
\end{figure}
\end{comment}

\section{Analisi delle prestazioni}\label{analisi-delle-prestazioni}
La tabella sottostante mostra gli speedup $S$ (misura quantitativa delle performance) che il sistema raggiunge a seconda del numero di worker utilizzati.\\
Lo speedup viene misurato calcolando il rapporto tra il tempo di esecuzione del sistema utilizzando un singolo worker e il tempo di esecuzione del sistema utilizzando un algoritmo parallelo.

\begin{equation}
 S = \frac{T_1}{T_N}
\end{equation}
Dove:
\begin{itemize}
    \item $N \leftarrow$ numero di worker utilizzati
    \item $T_1 \leftarrow$ tempo di esecuzione del sistema utilizzando un algoritmo sequenziale
    \item $T_N \leftarrow$ tempo di esecuzione del sistema utilizzando un algoritmo parallelo con $N$ worker
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{l|ccccccccc}
\hline
     & 2    & 3    & 4    & 5    & 6    & 7    & 8    & 9    & 10    \\ \hline
Min. & 1.86 & 2.48 & 2.55 & 2.73 & 2.82 & 2.81 & 2.80 & 2.86 & 12.95 \\
Max. & 1.44 & 1.75 & 2.41 & 2.49 & 2.35 & 2.53 & 2.45 & 2.39 & 12.34 \\
Avg. & 1.74 & 2.22 & 2.35 & 2.42 & 2.41 & 2.47 & 2.47 & 2.48 & 12.51 \\ \hline
\end{tabular}
\caption{Lo speedup è stato calcolato su 25 iterazioni considerando una schacchiera di gioco 5000x5000. Sulle colonne sono specificati il numero di worker utilizzati per la parallelizzazione dell'algoritmo, sulle righe i valori statistici (minimi, massimi e medi) degli speedup calcolati. Gli speedup sono stati calcolati su un Apple Macbook Pro (Retina, 15", metà 2015) dotato di un processore Intel Core i7 quad-core a 2.2GHz.
È possibile eseguire i benchmark lanciando la classe \texttt{pcd.ass03.ex1.Benchmark} e visualizzare sia le velocità di computazione di uno stato della scacchiera, sia i relativi speedup ottenuti.}
\label{speedup-table}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=110mm]{res/execution_times.png}
    \caption{Grafico che mostra l'evoluzione dei tempi di esecuzione (in ms) al crescere del numero di worker. I tempi di esecuzione sono stati calcolati come media su 25 iterazioni considerando una schacchiera di gioco 5000x5000. I tempi di esecuzione sono stati calcolati su un Apple Macbook Pro (Retina, 15", metà 2015) dotato di un processore Intel Core i7 quad-core a 2.2GHz.}
    \label{fig:execution-times}
\end{figure}

% Your document ends here!
\end{document}
